## Lesson 4. Building Polished User Interfaces

In this chapter you'll learn how to use several NativeScript features that let you build professional mobile user interfaces, such as listviews, layouts, and animations.

In the process you’ll complete the Groceries app, and have a functioning list-based app that you can share with your friends. Let’s get started by looking at some things you can do to customize NativeScript UI components.

### Step 1. Customizing UI components

Each UI component has a set of properties and methods you can use to customize your app.

#### Background: NativeScript modules

All NativeScript UI components are implemented as NativeScript modules, which are a series of TypeScript modules you use to add powerful functionality to your apps. There are a [lot of these modules](https://docs.nativescript.org/angular/core-concepts/modules), and you will use several of them as you complete this tutorial.

The source code for the NativeScript modules lives on GitHub in the [NativeScript/NativeScript repo](https://github.com/nativescript/nativescript). The modules are [distributed through npm as a “tns-core-modules” package](https://www.npmjs.com/package/tns-core-modules), which all NativeScript apps depend on. Because the NativeScript modules are open source, you are welcome to [contribute changes](https://www.nativescript.org/contribute).

#### End Background

In the next example you’re going to hide the `<ActionBar>` on the login page. On Android an `<ActionBar>` shows in your app even if you don’t explicitly include an `<ActionBar>` in your template. (The title defaults to the name of your app.) To hide the `<ActionBar>` you have to set a property of the `<Page>` object.

<hr data-action="start" />

#### Action

* **a.** Open your `app/views/login/login.js` file, and add following code to the `exports.loaded()` function under the declaration for `page` .

``` JavaScript
page.actionBarHidden = true;
```

#### Background: About the Page class

This code uses an instance of the [`Page` class](https://docs.nativescript.org/api-reference/classes/_ui_page_.page.html) from the [NativeScript page module](https://docs.nativescript.org/api-reference/modules/_ui_page_.html), and sets its `actionBarHidden` property to `true`, which hides the ActionBar that shows by default on Android devices.

Although you can peruse the [NativeScript API documentation](http://docs.nativescript.org/api-reference/globals.html) for a full list of these properties and what they do, if you’re using a TypeScript-friendly IDE, you can get a full list of these properties at any point. You can see this behavior in NativeScript Playground as you type `this.page.` while editing your `login.component.ts` file.

#### End Background

Let's make one more change to the Login screen before moving on to build out the grocery list screen.

### Step 2. Enhancing the Login Screen

On the login page, we need to make the user experience better, so that it's clear whether the user is logging in or registering. Let's make the screen switch colors dynamically, depending on the user's choice.

TODO 

### Step 3. Introducing NativeScript UI

In addition to the NativeScript [core user interface components](https://docs.nativescript.org/ui/components), many of which you’ve used throughout this guide, NativeScript additionally provides a collection of free, professional components collectively known as [NativeScript UI](https://www.nativescript.org/ui-for-nativescript).

NativeScript UI contains controls for building drawers, listviews, calendars, charts, forms, autocompletes, and more. In fact, the graph you saw back in lesson one of this tutorial was a NativeScript UI component. To show what NativeScript UI can do, let’s look at to use the suite’s listview control to start to add a grocery list to your app.

#### Background: NativeScript plugins

NativeScript UI is a NativeScript plugin. [NativeScript plugins](https://docs.nativescript.org/plugins/plugins) are npm packages with some added native functionality, such as the ability to leverage Android and iOS SDKs.

Because NativeScript plugins require full iOS and Android builds to use, normally you cannot use NativeScript plugins in the NativeScript Playground environment.

However, a few NativeScript plugins have built-in support in NativeScript Playground, including NativeScript UI, [the accelerometer plugin](https://market.nativescript.org/plugins/nativescript-accelerometer), and the [geolocation plugin](https://market.nativescript.org/plugins/nativescript-geolocation). You can [learn more about using plugins on the NativeScript documentation](https://docs.nativescript.org/plugins/plugins), and you can [peruse available plugins on the NativeScript Marketplace](https://market.nativescript.org/plugins/nativescript-geolocation).

#### End background

<hr data-action="start">

#### Action

* **a.** Open `app/views/list/list.xml` and paste in the code below, which creates the list where your groceries will reside:

``` XML
<Page loaded="loaded" xmlns:lv="nativescript-pro-ui/listview">
    <GridLayout>
        <lv:RadListView items="{{ groceryList }}" row="1">
	        <lv:RadListView.itemTemplate>
	            <GridLayout class="grocery-list-item">
	                <Label class="p-15" text="{{ name }}"/>
	            </GridLayout>
	        </lv:RadListView.itemTemplate>
    		</lv:RadListView>
    </GridLayout>
</Page>
```
<hr data-action="end">

#### Background: The xmlns namespace

TODO

#### End Background

If you run this code as is, you won't see any items in the grocery list. First you need to build out a way to manage data within the list, and to do that you're going to need a new NativeScript module: the ObservableArray.

### Step 4. Working with Arrays

In the previous section of this guide you saw how to create observables and how to use them to connect XML views with code-behind files and view models. You're going to do the same thing in this section with one additional twist, and it involves making populating the `items` array.

The `RadListView` pro UI element's `items` attribute takes an array, and to create that array on the view model, NativeScript provides a special ObservableArray module. To see how it works, let's start building the list page's code-behind file.

<hr data-action="start">

#### Action

* **a.** Open `app/views/list/list.js` and paste in the following code:

``` JavaScript
var dialogsModule = require("ui/dialogs");
var observableModule = require("data/observable")
var ObservableArray = require("data/observable-array").ObservableArray;
var page;

var pageData = new observableModule.fromObject({
    groceryList: new ObservableArray([
        { name: "eggs" },
        { name: "bread" },
        { name: "cereal" }
    ])
});

exports.loaded = function(args) {
    page = args.object;
    page.bindingContext = pageData;
};
```
<hr data-action="end">

#### Background: The observable object

Here, you're creating a new Observable object called `pageData`, which you set as the page's `bindingContext` in the `loaded()` function. Inside the Observable, you set a single `"groceryList"` property to be a new instance of the ObservableArray class. Notice how the `"groceryList"` property corresponds to `<ListView items="{% raw %}{{ groceryList }}{% endraw %}">`, and each array entry's `"name"` property corresponds to `<Label text="{% raw %}{{ name }}{% endraw %}">`.

> **NOTE**: Notice how this example uses the observable module’s `fromObject()` method instead of the `Observable` class constructor. Both `observableModule.fromObject()` and `new Observable()` create a new `Observable` instance, however, the `fromObject()` method performs a bit of additional initialization to handle nested objects. This example uses `fromObject()` because the `pageData` observable object contains a nested `ObservableArray`.

#### End Background

If you run your app you'll see the list screen shows the hardcoded data:

** TODO insert pics of hardcoded screen data **

#### Background: More about the `p-15` class name

The NativeScript Core Theme contains a number of class names that let you control the spacing of UI components within your application.

The class names follow a convention of margin/padding - top/bottom/left/right - amount. So for example, `<Label class="m-t-2">` renders a label with a `margin-top` of `2`, and `<Label class="p-b-5">` renders a label with a `padding-bottom` of `5`.

Therefore, in the example above `<Label class="p-15">` applies `padding: 15` to the label. You can [learn more about these class names on the NativeScript docs](https://docs.nativescript.org/ui/theme#padding-and-margin).

#### End Background

Now that we have items on the screen let's look at how you can tie this list to a backend instead of hardcoded data. To do so you'll switch the list page to use a view model, much like you did with the login page.

A starting view model for this page is already in the file at `app/shared/view-models/grocery-list-view-model.js`, which contains code that looks a lot like what you already have in `list.js`:

``` JavaScript
var config = require("../../shared/config");
var fetchModule = require("fetch");
var ObservableArray = require("data/observable-array").ObservableArray;

function GroceryListViewModel(items) {
    var viewModel = new ObservableArray(items);
    return viewModel;
}

module.exports = GroceryListViewModel;
```

Let's expand on this to tie this view model to a backend.

<hr data-action="start">

#### Action

* **a.** Start by changing `app/views/list/list.js` to use the `GroceryListViewModel`. First, `require()` the `GroceryListViewModel` so you can use it:

``` JavaScript
var GroceryListViewModel = require("../shared/view-models/grocery-list-view-model");
```

* **b.** Next, **remove** the existing `var pageData` assignment:

``` JavaScript
// Remove these seven lines of code
var pageData = new observableModule.fromObject({
    groceryList: new ObservableArray([
        { name: "eggs" },
        { name: "bread" },
        { name: "cereal" }
    ])
});
```

* **c.** And add the code below in the same location:

``` JavaScript
var groceryList = new GroceryListViewModel([]);
var pageData = new observableModule.fromObject({
    groceryList: groceryList
});
```

* **d.** Finally, replace the existing `exports.loaded()` function with the one below, which calls two new methods on the view model—`empty()` and `load()`.

``` JavaScript
exports.loaded = function(args) {
    page = args.object;
    page.bindingContext = pageData;

    groceryList.empty();
    groceryList.load();
};
```

In this code, `groceryList` is referencing the grocery list model, and the `empty()` function empties the list, and then calls the view model's `load()` function to reload the data from the backend.

The last piece to make this work is actually implementing the `empty()` and `load()` functions in the view model. 

* **e.** Open `app/shared/view-models/grocery-list-view-model.js`, and paste the following code between the `var viewModel` assignment, and the `return viewModel` statement.

``` JavaScript
viewModel.load = function() {
    return fetch(config.apiUrl + "Groceries", {
        headers: {
            "Authorization": "Bearer " + config.token
        }
    })
    .then(handleErrors)
    .then(function(response) {
        return response.json();
    }).then(function(data) {
        data.Result.forEach(function(grocery) {
            viewModel.unshift({
                name: grocery.Name,
                id: grocery.Id
            });
        });
    });
};

viewModel.empty = function() {
    while (viewModel.length) {
        viewModel.pop();
    }
};
```

<hr data-action="end">

When your app refreshes on your device you’ll see a blank list page, but you didn’t do anything wrong! Your app now reads grocery data from a backend, but you don’t have any groceries associated with your new account.

To really test out these changes you’ll need to allow users to add groceries to their lists, so let’s look at how to do that next.

### Step 5. Using advanced layouts

In order to allow users to add to their grocery lists, you need to add a few additional UI controls to the list page. While you could use a simple `<StackLayout>` to stack up the controls you need, let’s look at how to create a slightly more complex layout using the `<GridLayout>` element.

<hr data-action="start" />

#### Action

* **a.** Open `app/views/list/list.xml` and change the `<GridLayout>` tag to use the code below:

``` XML
<GridLayout rows="auto, *">
```

The `rows` attribute divides the screen into two rows, the first auto-sized according to its childrens' height, and the other to contain \*, or the remaining height of the screen.

* **b.** Next, to give the user a way to add groceries to the list, add a text field and a button to the page. Add these two lines of code directly after the initial `<GridLayout>` tag:

``` XML
<GridLayout row="0" columns="*, auto" class="add-bar">
    <TextField id="groceryTextField" text="{% raw %}{{ grocery }}{% endraw %}" hint="Enter a grocery item" col="0"/>
    <Image src="~/images/add" tap="add" col="1"/>
</GridLayout>
```

#### Background: More details about this layout

The text field has an id attribute of `"grocery"`, and is bound to the `{% raw %}{{ grocery }}{% endraw %}` property of the page's binding context. The button's `tap` event refers to an `add()` function, that you'll add to the code-behind file momentarily.

But the most important thing to note here is the use of the `row` and `col` attributes. These attributes are zero-based, so the text field's `row="0" col="0"` attributes place it in the first row and first column, whereas the button's `row="0" col="1"` attributes place it in the first row and second column.

#### End Background

* **c.** Now you can make this box look nice by styling it with css. Open `app/views/list/list.css` and add the following code:

``` CSS
.add-bar {
  background-color: #CB1D00;
  padding: 5;
}
.add-bar Image {
  height: 15;
  vertical-align: center;
  margin-left: 10;
  margin-right: 10;
}
.add-bar TextField {
  padding: 10;
}
Label {
  background-color: white;
  border-bottom-width: 1;
  border-bottom-color: gray;
}
```

Now you just need to make the necessary changes to the code-behind file to support these XML changes. 

* **c.** Open `app/views/list/list.js` and start by adding a new `"grocery"` property to the `pageData` Observable. The `pageData` assignment should look like this:

``` JavaScript
var pageData = new observableModule.fromObject({
    groceryList: groceryList,
    grocery: ""
});
```

* **d.** Next, you need to add an `add()` function to handle the button tap event. Paste in the following code at the bottom of `list.js`:

``` JavaScript
exports.add = function() {
    // Check for empty submissions
    if (pageData.get("grocery").trim() === "") {
        dialogsModule.alert({
            message: "Enter a grocery item",
            okButtonText: "OK"
        });
        return;
    }

    // Dismiss the keyboard
    page.getViewById("grocery").dismissSoftInput();
    groceryList.add(pageData.get("grocery"))
        .catch(function() {
            dialogsModule.alert({
                message: "An error occurred while adding an item to your list.",
                okButtonText: "OK"
            });
        });

    // Empty the input field
    pageData.set("grocery", "");
};
```

In this function, you first ensure the user didn't submit without typing a grocery. If the user did type something, you dismiss the device's keyboard, then you get the `"grocery"` property from the page's binding context (which is bound to the new `<TextField>`), and pass that value to the view model's `add()` function.

* **e.** Finally, define that `add()` function. To do so, open `app/shared/view-models/grocery-list-view-model.js` and paste the following function under the `empty()` function, but before the `return viewModel` statement.

``` JavaScript
viewModel.add = function(grocery) {
    return fetch(config.apiUrl + "Groceries", {
        method: "POST",
        body: JSON.stringify({
            Name: grocery
        }),
        headers: {
            "Authorization": "Bearer " + config.token,
            "Content-Type": "application/json"
        }
    })
    .then(handleErrors)
    .then(function(response) {
        return response.json();
    })
    .then(function(data) {
        viewModel.push({ name: grocery, id: data.Result.Id });
    });
};
```
<hr data-action="end">

If you build and rerun your app, you'll find that you can add a grocery item and it will appear immediately in your list—and, all of this is completely driven by a backend service. Pretty cool, huh?

![list 3](/img/cli-getting-started/nativescript/chapter4/ios/4.gif)
![list 3](/img/cli-getting-started/nativescript/chapter4/android/4.gif)

At this point you’ve come a long way. You have a functional login screen and now a backend-driven list that you can add to. Before you finish this tutorial you have a few more tasks though. Let’s start by allowing users to delete from the list, and then move on to add a loading indicator and some animations.

### Step 6. Delete items from the list

NativeScript UI is a set of professional user interface components that includes a full charting library. As such, there are a tons of functionality you can use to enhance your applications.

In this step you’ll leverage one feature of the `<RadListView>` control, which you’ll use to allow users to delete groceries, and learn how to find out more about the NativeScript UI controls.

#### Background: Learning more about NativeScript UI

Because NativeScript UI has a lot of controls with a lot of features, it can be difficult to know where to start. Here are some recommendations.

* If you’re a video learner, start by watching [a tour of NativeScript UI on YouTube](https://www.youtube.com/watch?v=4JJVOxybR4E).
* If you like skimming documentation, the [NativeScript UI documentation](http://docs.telerik.com/devtools/nativescript-ui/Controls/Angular/overview) has a thorough list of the controls and the features they offer.
* If you like getting your hands on code right away, the [NativeScript UI Angular sample](https://github.com/telerik/nativescript-ui-samples-angular/) is a sample app that shows off every feature of NativeScript UI in action.

#### End Background

<hr data-action="start" />

#### Action

* **a.** 

TODO

* **e.** Save your files. When your device updates with these changes, you should now be able to swipe on individual items on your list and tap a button to delete them.

![](images/ios-20.gif)
![](images/android-20.gif)

<hr data-action="end" />

The NativeScript UI components have a ton of features that you can use to add powerful functionality to your applications. In the previous example you used the [`RadListView`’s swipe action capability](http://docs.telerik.com/devtools/nativescript-ui/Controls/NativeScript/ListView/swipe-actions), which allows users to swipe on list items to perform actions.

#### Background: Details on using swipe actions

To understand how this works, let’s start back with the opening `<RadListView>` tag from your markup.

``` XML
<RadListView row="1" [items]="groceryList" [class.visible]="listLoaded"
  swipeActions="true" (itemSwipeProgressStarted)="onSwipeCellStarted($event)">
```

Setting the `swipeActions` attribute to `true` is necessary to turn on the `<RadListView>`’s swipe behavior. From there, the control triggers [a number of events](http://docs.telerik.com/devtools/nativescript-ui/Controls/Angular/ListView/swipe-actions#swipe-actions) you can subscribe to configure exactly what you want to happen during swipes.

The only event you must subscribe to is the `itemSwipeProgressStarted` event, as you have to set a few values that control exactly how the swipe will work. With that in mind let’s look at your `onSwipeCellStarted` method and what it does.

``` TypeScript
onSwipeCellStarted(args: ListViewEventData) {
  var swipeLimits = args.data.swipeLimits;
  var swipeView = args.object;
  var rightItem = swipeView.getViewById<View>("delete-view");
  swipeLimits.right = rightItem.getMeasuredWidth();
  swipeLimits.left = 0;
  swipeLimits.threshold = rightItem.getMeasuredWidth() / 2;
}
```

The key here are the three lines of code at the bottom that set `right`, `left`, and `threshold` values. These values control the distance the user should be able to swipe right, swipe left, and the offset beyond which the swiped item will dock open, respectively.

In this example you’re saying the user should be able to swipe right for a distance that’s equal to the width of the delete button, that the user shouldn’t be able to swipe left, and that the user should be able to swipe half the width of the delete button before the button stays open.

> **NOTE**: Another popular way to configure swipe functionality is to perform an action automatically on swipe, without requiring the user to explicitly tap a button. The `<RadListView>` control supports this approach, and you read more about it on the [NativeScript UI documentation on the topic](http://docs.telerik.com/devtools/nativescript-ui/Controls/Angular/ListView/swipe-actions#swipe-actions).

#### End Background

Now that users can both add and delete groceries from a list, let’s finish up this tutorial by adding a little more polish to this list page. 

### Step 7. Adding a Loading Indicator

### Step 8. Creating engaging animations