## Lesson 3. Adding Application Logic

In this lesson you’ll learn how to add TypeScript logic to your app, how to create services that talk to backend endpoints, and how to architect an app to share code with Angular web apps. There’s a lot to cover, so let’s start by discussing how to handle events and data binding.

### Step 1. Handling events

Most user interfaces are driven by events. In NativeScript apps, those events are usually some user action, such as tapping, swiping, or rotating—and NativeScript abstracts the iOS- and Android-specific code for handling such events into a handful of easy-to-use APIs. Let’s start with the most common event you’ll use in a NativeScript app: `tap`.

<hr data-action="start" />

#### Action

* **a.** Open your `app/app.component.ts` file, find the existing sign in button within your component’s `template` (`<Button text="Sign in" class="btn btn-primary"></Button>`), and replace it with the following code:

``` XML
<Button text="Sign in" class="btn btn-primary" (tap)="submit()"></Button>
```

* **b.** Next, in the same file, replace the current `AppComponent` declaration (`export class AppComponent {}`) with the one shown below:

``` TypeScript
export class AppComponent {
  submit() {
    console.log("hello");
  }
}
```

* **c.** Save your `app/app.component.ts` file. When your app refreshes on your device tap the **Sign in** button. You should see “hello” listed in the **Logs** section of Playground in your browser.

> **TODO** Add a screenshot of the log

<hr data-action="end" />

The `(eventName)="functionName()"` syntax is part of [Angular’s event binding system](https://angular.io/docs/ts/latest/guide/template-syntax.html#!#event-binding), which lets you bind an event that occurs on a UI element to a function in your component’s class. In this case, the `(tap)="submit()"` syntax tells Angular to run the `AppComponent` class’s `submit()` function whenever the user taps the sign in button.

> **TIP**:
> * You can find a list of events available for each UI element on its API documentation page. For instance, the [button element’s API documentation](http://docs.nativescript.org/api-reference/classes/_ui_button_.button.html) lists its `tap` event.
> * The Angular docs have a helpful [cheat sheet](https://angular.io/docs/ts/latest/guide/cheatsheet.html) that includes the various syntaxes available when building templates. Don’t worry too much about knowing how all these work at the moment; you’ll the most common syntaxes as you complete this guide.

With the `tap` event in place, you now have a way of tying the UI elements in your template to your TypeScript code. To make a login page actually work though, we need to introduce one other way of connecting a template to code: data binding.

### Step 2. Binding to data

Angular provides several ways to bind data in your TypeScript code to UI controls, and through the magic of NativeScript those same methods are available in your iOS and Android apps.

The first of these is a way to bind UI attributes to properties defined in your TypeScript class. Let’s look at how it works.

<hr data-action="start">

#### Action

* **a.** In your `app/app.component.ts` file, replace the current `AppComponent` declaration with the one shown below, which adds a new `email` property, and changes the `submit()` method to display its value:

``` TypeScript
export class AppComponent {
  email = "nativescriptrocks@progress.com";
  submit() {
    alert("You’re using: " + this.email);
  }
}
```

* **b.** Next, find the first `<TextField>` in your component’s `template` and replace it with the code below, which adds a new `text` attribute:

``` XML
<TextField hint="Email Address" keyboardType="email"
  autocorrect="false" autocapitalizationType="none"
  [text]="email" class="input input-border"></TextField>
```

* **c.** Save your `app/app.component.ts` file. When your app refreshes on your device you should see the “nativescriptrocks” email address prefilled.

> **TODO**: Add images for iOS and Android.

<hr data-action="end">

The key thing to note here is the `[text]="email"` attribute on the `<TextField>`. This is Angular’s syntax for attribute binding, and it allows you to bind the value of an attribute to a property in your TypeScript class. In this case, the `text` attribute of the `<TextField>`—which is roughly equivalent to a DOM `<input>`’s `value` attribute—is bound to the `AppComponent`’s `email` property.

> **NOTE**: It’s very easy to confuse Angular’s event binding syntax `(eventName)="functionName()"` with its attribute binding syntax `[attributeName]="propertyName"`. Don’t worry though; if you get them backwards, the problem is usually easy to debug, as the functionality you’re attempting to add just won’t work. These syntaxes are common enough that you’ll be using them a lot, and eventually you should be able to commit them to memory.

#### Background: One-way binding versus two-way binding

The binding you used in the previous example is known as one-way binding, and it works well when you need TypeScript properties—and changes to those properties done in TypeScript code—to appear in the user interface. But in the case of UI components that accept user input, such as the text field in this example, usually you need data binding to work two way. Using two-way binding ensures that the values the user types into UI components are available in your TypeScript code.

If you’d like to confirm that your app is currently using one-way binding only, head back to your app and change the email text field’s value (type a few extra letters or something like that), and then tap the **Sign In** button. Because your `submit()` function alerts the current value of the component’s `email` property—`alert("You’re using: " + this.email)`—you might expect to see the updated value in the alert. Instead, however, you see the original value. Notice how the typed text and the alert value don’t match in the screenshot below.

> **TODO**: Add image showing email addresses not aligning.

#### End Background

Next let’s look at how to implement two-way binding in an Angular app.

<hr data-action="start" />

#### Action

* **a.** Open your `app/app.component.ts` file, find the first `<TextField>`, and replace it with the `<TextField>` below, which introduces a new `[(ngModel)]` attribute:

``` XML
<TextField hint="Email Address" keyboardType="email"
  autocorrect="false" autocapitalizationType="none"
  [(ngModel)]="email" class="input input-border"></TextField>
```

* **b.** Next, open your `app/app.module.ts` file, and replaces its contents with the code below, which adds a new `NativeScriptFormsModule` to the `NgModule`’s list of `imports`.

``` TypeScript
import { NgModule } from "@angular/core";
import { NativeScriptFormsModule } from "nativescript-angular/forms";
import { NativeScriptModule } from "nativescript-angular/nativescript.module";
import { NativeScriptUIChartModule } from "nativescript-pro-ui/chart/angular";

import { AppComponent } from "./app.component";

@NgModule({
  imports: [
    NativeScriptModule,
    NativeScriptFormsModule,
    NativeScriptUIChartModule
  ],
  declarations: [AppComponent],
  bootstrap: [AppComponent]
})
export class AppModule {}
```

> **NOTE**: You can think of the list of `imports` in an Angular module as the pieces of functionality needed to make your app work. In this case, the `NativeScriptFormsModule` makes the `[(ngModel)]` syntax work with NativeScript’s UI components. If you want to dive into exactly how Angular imports work, refer to [Angular’s documentation on modules](https://angular.io/docs/ts/latest/guide/ngmodule.html).

* **c.** Save your `app/app.component.ts` and `app/app.module.ts` files.

* **d.** After your app updates on your device, make a change to the email address (type a few extra characters or something), and tap the app’s **Sign in** button. You should now see the updated email address in an alert.

> **TODO:** Images for iOS and Android

<hr data-action="end" />

At first glance the `[(ngModel)]` syntax looks more than a little odd, as it’s essentially a combination of the event and attribute binding syntax that you used in earlier examples. In the case of this example, `[(ngModel)]="email"` is shorthand for `[text]="email" (ngModelChange)="email=$event"`, which binds the email element’s `text` attribute to an `email` property and adds a `change` event handler that updates the `email` property’s value whenever the user makes a change.

Don’t worry too much about the details of this syntax while you’re getting started. In your head you can think of `[(ngModel)]` as the way to implement two-way data binding when you need it on form controls.

Before we move on, let’s make one additional change to show what else you can do with Angular’s data binding APIs. The Groceries app uses the same UI for the **Sign In** form and the **Sign Up** form. Therefore, when the user taps **Sign Up**, you need to update the text of the buttons (and eventually the functionality that occurs when you tap them). Let’s see how to make that happen.

<hr data-action="start" />

#### Action

* **a.** Open your `app/app.component.ts` file and replace the two existing `<Button>`s with the code below.

``` XML
<Button [text]="isLoggingIn ? 'Sign in' : 'Sign up'" 
  class="btn btn-primary" (tap)="submit()"></Button>
<Button [text]="isLoggingIn ? 'Sign up' : 'Back to login'"
  (tap)="toggleDisplay()"></Button>
```

* **b.** Next, replace the existing `AppComponent` declaration with the code below, which adds a new `isLoggingIn` property, and a new `toggleDisplay()` method:

``` TypeScript
export class AppComponent {
  email = "nativescriptrocks@progress.com";
  isLoggingIn = true;

  submit() {
    alert("You’re using: " + this.email);
  }

  toggleDisplay() {
    this.isLoggingIn = !this.isLoggingIn;
  }
}
```

* **c.** Save your `app/app.component.ts` file.

* **d.** After you app updates on your device, tap the bottom button a few times. Notice how Angular is smart enough to update the button text when the TypeScript property changes.

<hr data-action="end" />

At this point, you have a basic login screen setup with two-way data binding—which isn’t bad for 20 some lines of TypeScript. (Think about how much code you’d have to write in Android Studio _and_ Xcode to accomplish the same task.) To this point though you’ve been placing all of your logic in a single TypeScript file, which doesn’t scale all that well for real-world applications.

Before we tie this app to a backend and make this login screen fully functional, let’s take a step back and set up a structure that can scale.

### Step 3. Structuring your app


### Step 4. Building services


### Step 5. Add navigation with routing